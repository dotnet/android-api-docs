<Type Name="ServiceLoader" FullName="Java.Util.ServiceLoader">
  <TypeSignature Language="C#" Value="public sealed class ServiceLoader : Java.Lang.Object, IDisposable, Java.Interop.IJavaPeerable, Java.Lang.IIterable" FrameworkAlternate="net-android-34.0;net-android-35.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceLoader extends Java.Lang.Object implements class Android.Runtime.IJavaObject, class Java.Interop.IJavaPeerable, class Java.Lang.IIterable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Java.Util.ServiceLoader" />
  <TypeSignature Language="F#" Value="type ServiceLoader = class&#xA;    inherit Object&#xA;    interface IIterable&#xA;    interface IJavaObject&#xA;    interface IDisposable&#xA;    interface IJavaPeerable" />
  <TypeSignature Language="C#" Value="public sealed class ServiceLoader : Java.Lang.Object, IDisposable, Java.Lang.IIterable" FrameworkAlternate="net-android-36.0" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Java.Lang.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Android.Runtime.IJavaObject</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Java.Interop.IJavaPeerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Java.Lang.IIterable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[Android.Runtime.Register("java/util/ServiceLoader", DoNotGenerateAcw=true)]</AttributeName>
      <AttributeName Language="F#">[&lt;Android.Runtime.Register("java/util/ServiceLoader", DoNotGenerateAcw=true)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[Java.Interop.JavaTypeParameters(new System.String[] { "S" })]</AttributeName>
      <AttributeName Language="F#">[&lt;Java.Interop.JavaTypeParameters(new System.String[] { "S" })&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs since="9">
    <param name="&lt;S&gt;&lt;S&gt;">The type of the service to be loaded by this loader</param>
    <summary>A facility to load implementations of a service.</summary>
    <remarks>
      <para>A facility to load implementations of a service.</para>
      <para>A <i>service</i> is a well-known interface or class for which zero, one,
            or many service providers exist. A <i>service provider</i> (or just
            <i>provider</i>) is a class that implements or subclasses the well-known
            interface or class. A <c>ServiceLoader</c> is an object that locates and
            loads service providers deployed in the run time environment at a time of an
            application's choosing. Application code refers only to the service, not to
            service providers, and is assumed to be capable of choosing between multiple
            service providers (based on the functionality they expose through the service),
            and handling the possibility that no service providers are located.
            
            &lt;h2&gt; Obtaining a service loader &lt;/h2&gt;</para>
      <para>An application obtains a service loader for a given service by invoking
            one of the static <c>load</c> methods of <c>ServiceLoader</c>. &lt;!--If the
            application is a module, then its module declaration must have a <i>uses</i>
            directive that specifies the service; this helps to locate providers and ensure
            they will execute reliably. In addition, if the application module does not
            contain the service, then its module declaration must have a <i>requires</i>
            directive that specifies the module which exports the service. It is strongly
            recommended that the application module does &lt;b&gt;not&lt;/b&gt; require modules which
            contain providers of the service.--/&gt;</para>
      <para>A service loader can be used to locate and instantiate providers of the
            service by means of the <c>#iterator() iterator</c> method. <c>ServiceLoader</c>
            also defines the <c>#stream() stream</c> method to obtain a stream of providers
            that can be inspected and filtered without instantiating them.</para>
      <para>As an example, suppose the service is <c>com.example.CodecFactory</c>, an
            interface that defines methods for producing encoders and decoders:</para>
      <code lang="text/java">{@code
                package com.example;
                public interface CodecFactory {
                    Encoder getEncoder(String encodingName);
                    Decoder getDecoder(String encodingName);
                }
            }</code>
      <para>The following code obtains a service loader for the <c>CodecFactory</c>
            service, then uses its iterator (created automatically by the enhanced-for
            loop) to yield instances of the service providers that are located:</para>
      <code lang="text/java">{@code
                ServiceLoader&lt;CodecFactory&gt; loader = ServiceLoader.load(CodecFactory.class);
                for (CodecFactory factory : loader) {
                    Encoder enc = factory.getEncoder("PNG");
                    if (enc != null)
                        ... use enc to encode a PNG file
                        break;
                    }
            }</code>
      <para>Sometimes an application may wish to inspect a service provider before
            instantiating it, in order to determine if an instance of that service
            provider would be useful. For example, a service provider for <c>CodecFactory</c> that is capable of producing a "PNG" encoder may be annotated
            with <c>@PNG</c>. The following code uses service loader's <c>stream</c>
            method to yield instances of <c>Provider&lt;CodecFactory&gt;</c> in contrast to
            how the iterator yields instances of <c>CodecFactory</c>:</para>
      <code lang="text/java">{@code
                ServiceLoader&lt;CodecFactory&gt; loader = ServiceLoader.load(CodecFactory.class);
                Set&lt;CodecFactory&gt; pngFactories = loader
                       .stream()                                              // Note a below
                       .filter(p -&gt; p.type().isAnnotationPresent(PNG.class))  // Note b
                       .map(Provider::get)                                    // Note c
                       .collect(Collectors.toSet());
            }</code>
      <para>&lt;ol type="a"&gt;
              &lt;li&gt; A stream of <c>Provider&lt;CodecFactory&gt;</c> objects &lt;/li&gt;
              &lt;li&gt; <c>p.type()</c> yields a <c>Class&lt;CodecFactory&gt;</c>&lt;/li&gt;
              &lt;li&gt; <c>get()</c> yields an instance of <c>CodecFactory</c>&lt;/li&gt;
            &lt;/ol&gt;
            
            &lt;h2&gt; Designing services &lt;/h2&gt;</para>
      <para>A service is a single type, usually an interface or abstract class. A
            concrete class can be used, but this is not recommended. The type may have
            any accessibility. The methods of a service are highly domain-specific, so
            this API specification cannot give concrete advice about their form or
            function. However, there are two general guidelines:
            &lt;ol&gt;
              &lt;li&gt;</para>
      <para>A service should declare as many methods as needed to allow service
              providers to communicate their domain-specific properties and other
              quality-of-implementation factors. An application which obtains a service
              loader for the service may then invoke these methods on each instance of
              a service provider, in order to choose the best provider for the
              application.</para>
      <para>&lt;/li&gt;
              &lt;li&gt;</para>
      <para>A service should express whether its service providers are intended
              to be direct implementations of the service or to be an indirection
              mechanism such as a "proxy" or a "factory". Service providers tend to be
              indirection mechanisms when domain-specific objects are relatively
              expensive to instantiate; in this case, the service should be designed
              so that service providers are abstractions which create the "real"
              implementation on demand. For example, the <c>CodecFactory</c> service
              expresses through its name that its service providers are factories
              for codecs, rather than codecs themselves, because it may be expensive
              or complicated to produce certain codecs.</para>
      <para>&lt;/li&gt;
            &lt;/ol&gt;
            
            &lt;h2&gt; "developing-service-providers"&gt;Developing service providers&lt;/h2&gt;</para>
      <para>A service provider is a single type, usually a concrete class. An
            interface or abstract class is permitted because it may declare a static
            provider method, discussed later. The type must be public and must not be
            an inner class.</para>
      <para>A service provider and its supporting code may be developed in a module,
            which is then deployed on the application module path or in a modular
            image. Alternatively, a service provider and its supporting code may be
            packaged as a JAR file and deployed on the application class path. The
            advantage of developing a service provider in a module is that the provider
            can be fully encapsulated to hide all details of its implementation.</para>
      <para>An application that obtains a service loader for a given service is
            indifferent to whether providers of the service are deployed in modules or
            packaged as JAR files. The application instantiates service providers via
            the service loader's iterator, or via <c>Provider Provider</c> objects in
            the service loader's stream, without knowledge of the service providers'
            locations.
            
            &lt;h2&gt; Deploying service providers on the class path &lt;/h2&gt;
            
            A service provider that is packaged as a JAR file for the class path is
            identified by placing a <i>provider-configuration file</i> in the resource
            directory <c>META-INF/services</c>. The name of the provider-configuration
            file is the fully qualified binary name of the service. The provider-configuration
            file contains a list of fully qualified binary names of service providers, one
            per line.</para>
      <para>For example, suppose the service provider
            <c>com.example.impl.StandardCodecs</c> is packaged in a JAR file for the
            class path. The JAR file will contain a provider-configuration file named:
            
            &lt;blockquote&gt;<c>META-INF/services/com.example.CodecFactory</c>&lt;/blockquote&gt;
            
            that contains the line:
            
            &lt;blockquote&gt;<c>com.example.impl.StandardCodecs # Standard codecs</c>&lt;/blockquote&gt;</para>
      <para>"format"&gt;The provider-configuration file must be encoded in UTF-8. 
            Space and tab characters surrounding each service provider's name, as well as
            blank lines, are ignored. The comment character is <c>'#'</c>
            (<c>U+0023</c>&lt;span style="font-size:smaller;"&gt;NUMBER SIGN&lt;/span&gt;);
            on each line all characters following the first comment character are ignored.
            If a service provider class name is listed more than once in a
            provider-configuration file then the duplicate is ignored. If a service
            provider class is named in more than one configuration file then the duplicate
            is ignored.</para>
      <para>A service provider that is mentioned in a provider-configuration file may
            be located in the same JAR file as the provider-configuration file or in a
            different JAR file. The service provider must be visible from the class loader
            that is initially queried to locate the provider-configuration file; this is
            not necessarily the class loader which ultimately locates the
            provider-configuration file.
            
            &lt;h2&gt; Timing of provider discovery &lt;/h2&gt;</para>
      <para>Service providers are loaded and instantiated lazily, that is, on demand.
            A service loader maintains a cache of the providers that have been loaded so
            far. Each invocation of the <c>iterator</c> method returns an <c>Iterator</c>
            that first yields all of the elements cached from previous iteration, in
            instantiation order, and then lazily locates and instantiates any remaining
            providers, adding each one to the cache in turn. Similarly, each invocation
            of the stream method returns a <c>Stream</c> that first processes all
            providers loaded by previous stream operations, in load order, and then lazily
            locates any remaining providers. Caches are cleared via the <c>#reload
            reload</c> method.
            
            &lt;h2&gt; "errors"&gt;Errors&lt;/h2&gt;</para>
      <para>When using the service loader's <c>iterator</c>, the <c>Iterator#hasNext() hasNext</c> and <c>Iterator#next() next</c> methods will
            fail with <c>ServiceConfigurationError</c> if an error occurs locating,
            loading or instantiating a service provider. When processing the service
            loader's stream then <c>ServiceConfigurationError</c> may be thrown by any
            method that causes a service provider to be located or loaded.</para>
      <para>When loading or instantiating a service provider in a module, <c>ServiceConfigurationError</c> can be thrown for the following reasons:</para>
      <para>When reading a provider-configuration file, or loading or instantiating
            a provider class named in a provider-configuration file, then <c>ServiceConfigurationError</c> can be thrown for the following reasons:
            
            &lt;ul&gt;
            
              &lt;li&gt; The format of the provider-configuration file violates the format specified above; &lt;/li&gt;
            
              &lt;li&gt; An <c>IOException IOException</c> occurs while reading the
              provider-configuration file; &lt;/li&gt;
            
              &lt;li&gt; A service provider cannot be loaded; &lt;/li&gt;
            
              &lt;li&gt; A service provider is not assignable to the service's interface or
              class, or does not define a provider constructor, or cannot be
              instantiated. &lt;/li&gt;
            
            &lt;/ul&gt;
            
            &lt;h2&gt; Concurrency &lt;/h2&gt;</para>
      <para>Instances of this class are not safe for use by multiple concurrent
            threads.
            
            &lt;h3&gt; Null handling &lt;/h3&gt;</para>
      <para>Unless otherwise specified, passing a <c>null</c> argument to any
            method in this class will cause a <c>NullPointerException</c> to be thrown.</para>
      <para>Added in 1.6.</para>
      <para>
        <format type="text/html">
          <a href="https://developer.android.com/reference/java/util/ServiceLoader" title="Reference documentation">Java documentation for <code>java.util.ServiceLoader</code>.</a>
        </format>
      </para>
      <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
    </remarks>
    <since version="Added in API level 9" />
  </Docs>
  <Members>
    <Member MemberName="FindFirst">
      <MemberSignature Language="C#" Value="public Java.Util.Optional? FindFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Util.Optional FindFirst() cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.ServiceLoader.FindFirst" />
      <MemberSignature Language="F#" Value="member this.FindFirst : unit -&gt; Java.Util.Optional" Usage="serviceLoader.FindFirst " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("findFirst", "()Ljava/util/Optional;", "", ApiSince=34)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("findFirst", "()Ljava/util/Optional;", "", ApiSince=34)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android34.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android34.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Util.Optional</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Load the first available service provider of this loader's service.</summary>
        <returns>The first service provider or empty <c>Optional</c> if no
                    service providers are located</returns>
        <remarks>
          <para>Load the first available service provider of this loader's service. This
            convenience method is equivalent to invoking the <c>#iterator()
            iterator()</c> method and obtaining the first element. It therefore
            returns the first element from the provider cache if possible, it
            otherwise attempts to load and instantiate the first provider.</para>
          <para>The following example loads the first available service provider. If
            no service providers are located then it uses a default implementation.</para>
          <code lang="text/java">{@code
               CodecFactory factory = ServiceLoader.load(CodecFactory.class)
                                                   .findFirst()
                                                   .orElse(DEFAULT_CODECSET_FACTORY);
            }</code>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/ServiceLoader#findFirst()" title="Reference documentation">Java documentation for <code>java.util.ServiceLoader.findFirst()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Iterator">
      <MemberSignature Language="C#" Value="public Java.Util.IIterator? Iterator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Java.Util.IIterator Iterator() cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.ServiceLoader.Iterator" />
      <MemberSignature Language="F#" Value="abstract member Iterator : unit -&gt; Java.Util.IIterator&#xA;override this.Iterator : unit -&gt; Java.Util.IIterator" Usage="serviceLoader.Iterator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Java.Lang.IIterable.Iterator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("iterator", "()Ljava/util/Iterator;", "")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("iterator", "()Ljava/util/Iterator;", "")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Util.IIterator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lazily loads the available providers of this loader's service.</summary>
        <returns>An iterator that lazily loads providers for this loader's
                     service</returns>
        <remarks>
          <para>Lazily loads the available providers of this loader's service.</para>
          <para>The iterator returned by this method first yields all of the
            elements of the provider cache, in instantiation order.  It then lazily
            loads and instantiates any remaining providers, adding each one to the
            cache in turn.</para>
          <para>To achieve laziness the actual work of parsing the available
            provider-configuration files and instantiating providers must be done by
            the iterator itself.  Its <c>java.util.Iterator#hasNext hasNext</c> and
            <c>java.util.Iterator#next next</c> methods can therefore throw a
            <c>ServiceConfigurationError</c> if a provider-configuration file
            violates the specified format, or if it names a provider class that
            cannot be found and instantiated, or if the result of instantiating the
            class is not assignable to the service type, or if any other kind of
            exception or error is thrown as the next provider is located and
            instantiated.  To write robust code it is only necessary to catch <c>ServiceConfigurationError</c> when using a service iterator.</para>
          <para>If such an error is thrown then subsequent invocations of the
            iterator will make a best effort to locate and instantiate the next
            available provider, but in general such recovery cannot be guaranteed.
            
            &lt;blockquote style="font-size: smaller; line-height: 1.2"&gt;&lt;span
            style="padding-right: 1em; font-weight: bold"&gt;Design Note&lt;/span&gt;
            Throwing an error in these cases may seem extreme.  The rationale for
            this behavior is that a malformed provider-configuration file, like a
            malformed class file, indicates a serious problem with the way the Java
            virtual machine is configured or is being used.  As such it is
            preferable to throw an error rather than try to recover or, even worse,
            fail silently.&lt;/blockquote&gt;</para>
          <para>The iterator returned by this method does not support removal.
            Invoking its <c>java.util.Iterator#remove() remove</c> method will
            cause an <c>UnsupportedOperationException</c> to be thrown.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/ServiceLoader#iterator()" title="Reference documentation">Java documentation for <code>java.util.ServiceLoader.iterator()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 9" />
      </Docs>
    </Member>
    <Member MemberName="Java.Interop.IJavaPeerable.UnregisterFromRuntime">
      <MemberSignature Language="C#" Value="void IJavaPeerable.UnregisterFromRuntime ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void Java.Interop.IJavaPeerable.UnregisterFromRuntime() cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.ServiceLoader.Java#Interop#IJavaPeerable#UnregisterFromRuntime" />
      <MemberSignature Language="F#" Value="abstract member Java.Interop.IJavaPeerable.UnregisterFromRuntime : unit -&gt; unit&#xA;override this.Java.Interop.IJavaPeerable.UnregisterFromRuntime : unit -&gt; unit" Usage="serviceLoader.Java.Interop.IJavaPeerable.UnregisterFromRuntime " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Java.Interop.IJavaPeerable.UnregisterFromRuntime</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="JniPeerMembers">
      <MemberSignature Language="C#" Value="public override Java.Interop.JniPeerMembers JniPeerMembers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Java.Interop.JniPeerMembers JniPeerMembers" />
      <MemberSignature Language="DocId" Value="P:Java.Util.ServiceLoader.JniPeerMembers" />
      <MemberSignature Language="F#" Value="member this.JniPeerMembers : Java.Interop.JniPeerMembers" Usage="Java.Util.ServiceLoader.JniPeerMembers" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Java.Interop.IJavaPeerable.JniPeerMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Interop.JniPeerMembers</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static Java.Util.ServiceLoader? Load (Java.Lang.Class? service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Util.ServiceLoader Load(class Java.Lang.Class service) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.ServiceLoader.Load(Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="static member Load : Java.Lang.Class -&gt; Java.Util.ServiceLoader" Usage="Java.Util.ServiceLoader.Load service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("load", "(Ljava/lang/Class;)Ljava/util/ServiceLoader;", "")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("load", "(Ljava/lang/Class;)Ljava/util/ServiceLoader;", "")&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[Java.Interop.JavaTypeParameters(new System.String[] { "S" })]</AttributeName>
          <AttributeName Language="F#">[&lt;Java.Interop.JavaTypeParameters(new System.String[] { "S" })&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Util.ServiceLoader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="service">The interface or abstract class representing the service</param>
        <summary>Creates a new service loader for the given service type, using the
            current thread's java.</summary>
        <returns>A new service loader</returns>
        <remarks>
          <para>Creates a new service loader for the given service type, using the
            current thread's java.lang.Thread#getContextClassLoader
            context class loader.</para>
          <para>An invocation of this convenience method of the form
            
            &lt;blockquote&gt;</para>
          <code lang="text/java">ServiceLoader.load(&lt;i&gt;service&lt;/i&gt;)</code>
          <para>&lt;/blockquote&gt;
            
            is equivalent to
            
            &lt;blockquote&gt;</para>
          <code lang="text/java">ServiceLoader.load(&lt;i&gt;service&lt;/i&gt;,
                               Thread.currentThread().getContextClassLoader())</code>
          <para>&lt;/blockquote&gt;</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/ServiceLoader#load(java.lang.Class%3CS%3E)" title="Reference documentation">Java documentation for <code>java.util.ServiceLoader.load(java.lang.Class&lt;S&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static Java.Util.ServiceLoader? Load (Java.Lang.Class? service, Java.Lang.ClassLoader? loader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Util.ServiceLoader Load(class Java.Lang.Class service, class Java.Lang.ClassLoader loader) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.ServiceLoader.Load(Java.Lang.Class,Java.Lang.ClassLoader)" />
      <MemberSignature Language="F#" Value="static member Load : Java.Lang.Class * Java.Lang.ClassLoader -&gt; Java.Util.ServiceLoader" Usage="Java.Util.ServiceLoader.Load (service, loader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("load", "(Ljava/lang/Class;Ljava/lang/ClassLoader;)Ljava/util/ServiceLoader;", "")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("load", "(Ljava/lang/Class;Ljava/lang/ClassLoader;)Ljava/util/ServiceLoader;", "")&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[Java.Interop.JavaTypeParameters(new System.String[] { "S" })]</AttributeName>
          <AttributeName Language="F#">[&lt;Java.Interop.JavaTypeParameters(new System.String[] { "S" })&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Util.ServiceLoader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="Java.Lang.Class" />
        <Parameter Name="loader" Type="Java.Lang.ClassLoader" />
      </Parameters>
      <Docs>
        <param name="service">The interface or abstract class representing the service</param>
        <param name="loader">The class loader to be used to load provider-configuration files
                    and provider classes, or <c>null</c> if the system class
                    loader (or, failing that, the bootstrap class loader) is to be
                    used</param>
        <summary>Creates a new service loader for the given service type and class
            loader.</summary>
        <returns>A new service loader</returns>
        <remarks>
          <para>Creates a new service loader for the given service type and class
            loader.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/ServiceLoader#load(java.lang.Class%3CS%3E,%20java.lang.ClassLoader)" title="Reference documentation">Java documentation for <code>java.util.ServiceLoader.load(java.lang.Class&lt;S&gt;, java.lang.ClassLoader)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadInstalled">
      <MemberSignature Language="C#" Value="public static Java.Util.ServiceLoader? LoadInstalled (Java.Lang.Class? service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Util.ServiceLoader LoadInstalled(class Java.Lang.Class service) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.ServiceLoader.LoadInstalled(Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="static member LoadInstalled : Java.Lang.Class -&gt; Java.Util.ServiceLoader" Usage="Java.Util.ServiceLoader.LoadInstalled service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("loadInstalled", "(Ljava/lang/Class;)Ljava/util/ServiceLoader;", "")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("loadInstalled", "(Ljava/lang/Class;)Ljava/util/ServiceLoader;", "")&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[Java.Interop.JavaTypeParameters(new System.String[] { "S" })]</AttributeName>
          <AttributeName Language="F#">[&lt;Java.Interop.JavaTypeParameters(new System.String[] { "S" })&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Util.ServiceLoader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="service">The interface or abstract class representing the service</param>
        <summary>Creates a new service loader for the given service type, using the
            extension class loader.</summary>
        <returns>A new service loader</returns>
        <remarks>
          <para>Creates a new service loader for the given service type, using the
            extension class loader.</para>
          <para>This convenience method simply locates the extension class loader,
            call it <c><i>extClassLoader</i></c>, and then returns
            
            &lt;blockquote&gt;</para>
          <code lang="text/java">ServiceLoader.load(&lt;i&gt;service&lt;/i&gt;, &lt;i&gt;extClassLoader&lt;/i&gt;)</code>
          <para>&lt;/blockquote&gt;</para>
          <para>If the extension class loader cannot be found then the system class
            loader is used; if there is no system class loader then the bootstrap
            class loader is used.</para>
          <para>This method is intended for use when only installed providers are
            desired.  The resulting service will only find and load providers that
            have been installed into the current Java virtual machine; providers on
            the application's class path will be ignored.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/ServiceLoader#loadInstalled(java.lang.Class%3CS%3E)" title="Reference documentation">Java documentation for <code>java.util.ServiceLoader.loadInstalled(java.lang.Class&lt;S&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reload">
      <MemberSignature Language="C#" Value="public void Reload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reload() cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.ServiceLoader.Reload" />
      <MemberSignature Language="F#" Value="member this.Reload : unit -&gt; unit" Usage="serviceLoader.Reload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("reload", "()V", "")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("reload", "()V", "")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clear this loader's provider cache so that all providers will be
            reloaded.</summary>
        <remarks>
          <para>Clear this loader's provider cache so that all providers will be
            reloaded.</para>
          <para>After invoking this method, subsequent invocations of the <c>#iterator() iterator</c> method will lazily look up and instantiate
            providers from scratch, just as is done by a newly-created loader.</para>
          <para>This method is intended for use in situations in which new providers
            can be installed into a running Java virtual machine.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/ServiceLoader#reload()" title="Reference documentation">Java documentation for <code>java.util.ServiceLoader.reload()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 9" />
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberSignature Language="DocId" Value="P:Java.Util.ServiceLoader.ThresholdClass" />
      <MemberSignature Language="F#" Value="member this.ThresholdClass : nativeint" Usage="Java.Util.ServiceLoader.ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.IntPtr" /> which contains the <c>java.lang.Class</c> JNI value corresponding to this type.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberSignature Language="DocId" Value="P:Java.Util.ServiceLoader.ThresholdType" />
      <MemberSignature Language="F#" Value="member this.ThresholdType : Type" Usage="Java.Util.ServiceLoader.ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.Type" /> which provides the declaring type.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
